//js code to run the path page of the webdashboard,
//which has a table and graph to create and view purepursuit paths

//The graph canvas from the html page
let graphCanvas = document.getElementById("graph");

//Create the graph using chart.js
let graph = new Chart(graphCanvas, {
    //Configures graph to give hover text over points
    responsive: true,
    //Configures graph to allow for access ratio changes
    maintainAspectRatio: false,
    //Configures graph type to scatter plot
    type: 'scatter',
    data: {
        //Sets the datasets to an empty array to be filled later
        datasets: []
    },
    options: {
        legend: {
            labels: {
                //Set the graph legend text to the --white color specified in style.css
                fontColor: getComputedStyle(document.documentElement).getPropertyValue('--white'),
                //Set the font size of the labels in the legend to 18px
                fontSize: 18
            }
        },
        scales: {
            yAxes: [{
                ticks: {
                    //Sets the graph yAxes tick color to the --graph color specified in style.css
                    fontColor: getComputedStyle(document.documentElement).getPropertyValue('--graph')
                }
            }],
            xAxes: [{
                ticks: {
                    //Sets the graph xAxes tick color to the --graph color specified in style.css
                    fontColor: getComputedStyle(document.documentElement).getPropertyValue('--graph')
                }
            }]
        },
        animation: {
            //Removes graph dataset change animations
            duration: 0
        }
    }
});

//Create an empty array for the points added by the user
let wayPoints = [];

//Create an empty array for the points generated by the program based on the way points entered by the user
let points = [];

//The spacing between each point
let spacing = 0.5;

//The threshold of point movement below which smoothing will end
let smoothingCompleteThreshold = 0.001;

//The amount of overall path smoothing
let SMOOTHING = 0.8;

//Opens the menu when a double click occurs anywhere on the page
function openMenu() {

    //Set the menu to be visible
    setVisibility(document.getElementById("menuPopup"), true);
}

//Closes the menu, called when the close button is pressed
function closeMenu() {

    //Hide the menu
    setVisibility(document.getElementById("menuPopup"), false);
}

//Copy to the system clipboard the current way points as a yaml array when the copy button is pressed
function copyToClipboard() {

    //Create a textarea in which the text will be put then copied to the system clipboard
    let textArea = document.createElement('textarea');

    //Create an empty array where the wey points to be copied will be put
    let path = "";

    //Loop through all the way points
    for (let point of wayPoints) {

        //Add each point to the path string
        path += "[" + point.x + ", " + point.y + "], ";
    }


    if (path.length > 0) {
        //If the path has points remove the extra comma and space from the last point
        path = path.trim().substring(0, path.length - 2);
    }

    //Add the extra brackets to make the way points into a yaml array
    path = "[" + path + "]";

    //Make the textarea read only to prevent the user from editing the array on accident
    textArea.setAttribute('readonly', '');

    //Set the value of the textarea to the yaml way point array
    textArea.value = path;

    //Set the textarea display to none so when it is added to the html page it will not be dipslayed
    textArea.display = 'none';

    //Add the textarea to the html page
    document.body.appendChild(textArea);

    //Select all the text in the textarea automatically
    textArea.select();

    //Execute the copy command copying the entire array onto the clipboard
    document.execCommand('copy');

    //Remove the textarea from the document now that the copy is complete
    document.body.removeChild(textArea);
}

//Opens the paste menu, called when the paste button is pressed
function openPaste() {

    //Set the paste menu to be visible
    setVisibility(document.getElementById("pastePopup"), true);

    //Select the paste input automatically
    document.getElementById('pathInput').focus();
    document.getElementById('pathInput').select();
}

//Closes the paste menu, called when the closePaste button is pressed
//"shouldPaste" is whether the data in the input will be put into the table and graph
function closePaste(shouldPaste) {
    if (shouldPaste) {
        //If the data should be put into the table and graph

        //Get the data from the input field
        let text = document.getElementById("pathInput").value;

        //Remove any special characters
        text = text.replace(/(\r\n|\n|\r|\s)/gm, "");

        //Remove the starting and ending brackets
        text = text.substring(1, text.length - 1);

        //Split up the input on the open brackets
        text = text.split("[");

        //Remove the empty first section
        text.splice(0, 1);

        //Clear the current data so the new data can be entered
        clearPath();

        //Get all the rows from the input table body
        let rows = document.getElementById("pointTableBody").rows;

        //Loop through each point
        for (let p in text) {

            //Remove the extra character to get "x,y" for the point
            let point = text[p].replace("],", "").replace("]", "");

            //Get the row that the data will be put into
            let row = rows[p];

            //Put the x-value in the first cell
            row.cells[0].innerText = point.split(",")[0];

            //Put the y-value in the second cell
            row.cells[1].innerText = point.split(",")[1];
        }

        //Update the page to show changes
        update();

        //Close the main menu
        closeMenu();
    }

    //Hide the paste menu
    setVisibility(document.getElementById("pastePopup"), false);
}

//Due to some oddities in chart.js, this function correctly sizes the graph for the page
function updateSize() {
    //Sets the graph height to the page body height minus the height of the tab bar
    graphCanvas.style.height = (document.body.clientHeight - 10) + 'px';
}

//Adds data to a dataset, creating a new dataset if needed
//"label" is the label of the dataset
//"data" is the data to be added to the dataset
function addData(label, data) {

    //Loop through all of the datasets on the graph to try and find a dataset with a matching label
    for (let dataset of graph.data.datasets) {

        if (dataset.label === label) {
            //If the labels match add the new data to the dataset

            //Loop through each point and add it to the dataset
            for (let point of data) {
                dataset.data.push(point);
            }

            //Update the graph to show changes
            graph.update();
            return;
        }
    }

    //If no dataset is found matching the label create a new dataset

    let dataset = {

        //Set the dataset label the the label passed in
        label: label,

        //Sets the label to the --graph color specified in style.css color specified in style.css
        labelColor: getComputedStyle(document.documentElement).getPropertyValue('--graph'),

        //Sets the point border and background colors --graph color specified in style.css color specified in style.css
        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--graph'),
        backgroundColor: getComputedStyle(document.documentElement).getPropertyValue('--graph'),

        //Sets the radius of the points to 5px
        pointRadius: 5,

        //Sets the data in the dataset to the data passed in
        data: data
    };

    //Add the dataset to the graph
    graph.data.datasets.push(dataset);

    //Update the graph to show changes
    graph.update();
}

//Removes all datasets from the graph
function removeData() {
    //Clears all datasets
    graph.data.datasets = [];

    //Updates the chart to display to changes
    graph.update();
}

//Removes all data from the path
function clearPath() {
    //Removes all the data
    localStorage['way_points'] = "";

    //Loops through each row in the input table body
    for (let row of document.getElementById("pointTableBody").rows) {

        //Clear the first cell in the row
        row.cells[0].innerText = "";

        //Clear the second cell in the row
        row.cells[1].innerText = "";
    }

    //Remove all data from the graph
    removeData();
}

//Mirrors the java build method in the purepursuit Path class
function build() {
    wayPoints = [];

    for (let row of document.getElementById("pointTableBody").rows) {
        if ((parseFloat(row.cells[0].innerText) || row.cells[0].innerText === '0') && (parseFloat(row.cells[1].innerText) || row.cells[1].innerText === '0')) wayPoints.push(new Point(parseFloat(row.cells[0].innerText), parseFloat(row.cells[1].innerText)));
    }

    localStorage['way_points'] = wayPoints.join("*");

    fill();

    smooth();

    return true;
}

//Mirrors the java fill method in the purepursuit Path class
function fill() {

    let newPoints = [];

    for (let s = 1; s < wayPoints.length; s++) {
        let vector = new Vector(wayPoints[s - 1], wayPoints[s]);

        let numPointsFit = Math.round(Math.ceil(vector.magnitude() / spacing));

        vector = vector.normalize().scale(spacing);

        for (let i = 0; i < numPointsFit; i++) {
            newPoints.push(wayPoints[s - 1].add(vector.scale(i)));
        }
    }

    newPoints.push(wayPoints[wayPoints.length - 1]);

    points = newPoints;
}

//Mirrors the java smooth method in the purepursuit Path class
function smooth() {
    let newPoints = [...points];

    let change = smoothingCompleteThreshold;
    while (change >= smoothingCompleteThreshold) {
        change = 0.0;
        for (let i = 1; i < points.length - 1; i++) {
            let point = newPoints[i];
            newPoints[i] = newPoints[i].add(new Point((1 - SMOOTHING) * (points[i].x - newPoints[i].x) + SMOOTHING * (newPoints[i - 1].x + newPoints[i + 1].x - (2.0 * newPoints[i].x)), (1 - SMOOTHING) * (points[i].y - newPoints[i].y) + SMOOTHING * (newPoints[i - 1].y + newPoints[i + 1].y - (2.0 * newPoints[i].y))));
            change += point.distance(newPoints[i]);
        }
    }

    points = newPoints;
}

//Update the path, called whenever the data changes
function update() {

    //Build the path with the new data
    build();

    //Remove the old data from the graph
    removeData();

    //Make an array for the new dataset
    let data = [];

    //Loop through each point
    for (let point of points) {
        if (point !== undefined) {
            //If the point is not undefined at it to the dataset
            data.push({x: point.x, y: point.y});
        }
    }

    //Put the new dataset onto the graph
    addData("Path", data);
}

//Used to show and hide an element
//"element" is the element
//"visible" is whether the element should be displayed
function setVisibility(element, visible) {
    //Show or hide the element using the visibility property based on the visible variable
    if (visible) {
        element.style.visibility = "visible";
    } else {
        element.style.visibility = "hidden";
    }

    //Get children of the element
    let children = element.children;

    //Loop through and show or hide the element's children using the visibility property based on the visible variable
    for (let c = 0; c < children.length; c++) {
        if (visible) {
            children[c].style.visibility = "visible";
        } else {
            children[c].style.visibility = "hidden";
        }
    }
}

//KeyListener which is added to each cell to allow the user to move the cursor with the up and down arrow keys
function keyListener(event) {

    if (event.key === "ArrowDown") {
        //If the key was the down arrow

        //Stop what the key would normally do
        event.preventDefault();

        //Get the rows of the input table
        let rows = document.getElementById("pointTable").rows;

        //Loop through the table rows
        for (let r = 0; r < rows.length; r++) {

            //Get the table row element
            let row = rows[r];

            if (row.cells[0] === event.target) {
                //If the target of the key event was the first cell in the row,
                //move the cursor to the second cell in the same row
                row.cells[1].focus();
            }

            if (row.cells[1] === event.target) {
                //If the target of the key event was the second cell in the row,
                //move the cursor to the first cell in the next row
                rows[r + 1].cells[0].focus();
            }
        }
    } else if (event.key === "ArrowUp") {
        //If the key was the up arrow

        //Stop what the key would normally do
        event.preventDefault();

        //Get the rows of the input table
        let rows = document.getElementById("pointTable").rows;

        //Loop through the table rows
        for (let r = 0; r < rows.length; r++) {

            //Get the table row element
            let row = rows[r];

            if (row.cells[0] === event.target) {
                //If the target of the key event was the first cell in the row,
                //move the cursor to the second cell in the previous row
                rows[r - 1].cells[1].focus();
            }

            if (row.cells[1] === event.target) {
                //If the target of the key event was the second cell in the row,
                //move the cursor to the first cell in the same row
                row.cells[0].focus();
            }
        }
    }

    //Update the table and graph every time any key is pressed
    setTimeout(update, 100);
}

//Create all the rows and cells in the way point input table
for (let i = 0; i < 100; i++) {

    //Create a new row
    let r = document.getElementById("pointTableBody").insertRow();

    //Create the first cell in the row
    let cell = r.insertCell(0);

    //Allow the user to edit the cell
    cell.contentEditable = 'true';

    //Add the keyListener for move the cursor to the cell
    cell.addEventListener("keydown", keyListener);

    //Create the second cell in the row
    cell = r.insertCell(1);

    //Allow the user to edit the cell
    cell.contentEditable = 'true';

    //Add the keyListener for move the cursor to the cell
    cell.addEventListener("keydown", keyListener);
}

if (localStorage['way_points'] !== undefined && localStorage['way_points'] !== "") {
    //If on page load the way points in local storage exist, then put them into the input table and graph

    //Get the way points from localStorage
    let points = localStorage['way_points'].split("*");

    //Loop through the way points
    for (let p in points) {

        //Get the way point from the array
        let point = points[p];

        //Get correct row from the data input table body
        let row = document.getElementById("pointTableBody").rows[p];

        //Put the x-value in the first cell
        row.cells[0].innerText = point.split(",")[0];

        //Put the y-value in the second cell
        row.cells[1].innerText = point.split(",")[1];
    }

    //Update the page to show changes
    update();
}

//Due to some oddities in chart.js, this makes sure the graph is sized correctly every 250 milliseconds
setInterval(updateSize, 250);